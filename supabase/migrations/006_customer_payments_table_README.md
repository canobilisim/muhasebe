# Migration 006: Customer Payments Table

## Overview
This migration creates a dedicated `customer_payments` table for tracking customer payment records. This replaces the previous approach of using negative sales records for payments.

## Changes

### New Table: `customer_payments`
- **Purpose**: Store customer payment records separately from sales transactions
- **Fields**:
  - `id`: UUID primary key
  - `customer_id`: Reference to customers table (required)
  - `amount`: Payment amount (must be positive)
  - `payment_type`: Payment method ('cash' or 'pos')
  - `payment_date`: Date and time of payment
  - `payment_number`: Auto-generated unique payment number (e.g., "ODM-20241021-000001")
  - `notes`: Optional payment notes
  - `branch_id`: Reference to branch (for multi-tenant support)
  - `user_id`: Reference to user who recorded the payment
  - `created_at`: Record creation timestamp
  - `updated_at`: Record update timestamp

### Indexes
- `idx_customer_payments_customer_id`: Fast lookup by customer
- `idx_customer_payments_payment_date`: Fast lookup by date
- `idx_customer_payments_branch_id`: Fast lookup by branch
- `idx_customer_payments_user_id`: Fast lookup by user

### RLS Policies
- Users can only view/insert/update/delete payments from their own branch
- All operations are branch-scoped for data isolation

### Triggers
- `trigger_update_customer_payments_updated_at`: Automatically updates `updated_at` field on record modification

## Benefits

1. **Better Data Model**: Payments are now separate from sales, making the data model cleaner and more maintainable
2. **Improved Queries**: Easier to query payment history without filtering negative sales
3. **Audit Trail**: Clear separation between sales and payments for better accounting
4. **Type Safety**: Proper TypeScript types for payment records

## Migration Path

### Before (Old Approach)
```typescript
// Creating a negative sale for payment
await SaleService.createSale({
  customerId: customer.id,
  items: [],
  paymentType: 'cash',
  totalAmount: -amount,
  netAmount: -amount,
  paidAmount: amount,
  notes: 'Müşteri ödemesi'
})
```

### After (New Approach)
```typescript
// Creating a proper payment record
// payment_number is auto-generated by the system
await CustomerPaymentService.createPayment({
  customer_id: customer.id,
  amount: amount,
  payment_type: 'cash',
  payment_date: new Date().toISOString(),
  notes: 'Hızlı satış ekranından alınan ödeme'
})
// Returns: { id, customer_id, amount, payment_type, payment_date, payment_number: "ODM-20241021-000001", ... }
```

## Related Changes

### Code Changes
- **FastSalePage.tsx**: Updated payment receive modal to use `CustomerPaymentService`
- **CustomerDetailPage.tsx**: Payment modal uses `CustomerPaymentService`
- **customerPaymentService.ts**: Service for managing payment records
- **customerService.ts**: Updated `getCustomerTransactions()` to include payments

### Type Definitions
- **types/index.ts**: Added `CustomerPayment`, `CustomerPaymentInsert`, `CustomerPaymentUpdate`, `CustomerPaymentWithDetails`
- **types/database.ts**: Added `customer_payments` table schema

## Testing

After applying this migration:

1. Test payment creation from Fast Sale page
2. Test payment creation from Customer Detail page
3. Verify customer balance updates correctly
4. Check customer transaction history includes both sales and payments
5. Verify RLS policies work correctly (branch isolation)

## Rollback

If needed, this migration can be rolled back by:
1. Dropping the `customer_payments` table
2. Reverting code changes to use negative sales for payments
3. Updating TypeScript types

```sql
-- Rollback script
DROP TABLE IF EXISTS public.customer_payments CASCADE;
```

## Notes

- Existing negative sales records (if any) are not migrated automatically
- The old `update_customer_balance` RPC function is no longer needed
- Customer balance updates are now done directly via `updateCustomer()`
